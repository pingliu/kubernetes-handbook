## 什么是Pod

Pod就像豌豆荚一样，可以包含多个容器，这些容器共享存储、网络、运行时申明。一个pod的内容总是位于同一宿主机、同时调度，运行在相同的环境内。你可以把pod想象成特殊定义的逻辑主机，它包含一个或多个紧密关联的应用容器，在有容器之前，这些应用都运行在同一物理机或者虚拟机上。

尽管kubernetes支持多种容器运行时，但是Docker依然是最常用的运行时环境，我们可以使用Docker的术语和规则来定义Pod。

Pod中共享的环境包括Linux的namespace，cgroup和其他可能的隔绝环境，这一点跟Docker容器一致。在Pod的环境中，每个容器中可能还有更小的子隔离环境。

在同一个pod中的容器共享ip和端口信息，可以通过localhost通信。它们可以通过进程间通信，比如`SystemV`信号或者`POSIX`共享内存。在不同pods中的容器具有独立的ip地址，不能通过IPC通信。这些容器通常通过各自的Pod IP进行通信。

在同一个pod的应用可以访问共享卷，这些卷被定义为pod的一部分，可以通过挂载成为应用程序的文件系统。

根据Docker的设计，一个pod中的容器共享namespaces和volumes。

就像独立的应用容器一样，pods是临时的实体。和在[pod生命周期](pod-life.md)中讨论一样，pods被创建，赋予唯一的UID，被调度到节点并直到删除。如果一个节点挂掉，在该节点的pod会在一段时间后被删除。一个给定的pod(比如UID定义的)不会被重新调度到新节点，相反的是通过同样的pod，甚至可以是同样的名字但是不同的UID来代替。

卷跟pod具有相同的生命周期。当pod由于任何原因被删除时，pod相关的东西(如卷)也会被销毁然后创建一个新的卷。

![Pod示意图](../images/pod-overview.png)

## Pod的动机

### 管理

Pod是一个服务的多个合作进程的模式。它们通过提供更高级别的抽象来简化应用的部署和管理。Pods作为一个单元，支持部署，横向扩展，复制。协同调度，共享命运，复制协调，资源共享，依赖管理，这些问题pod都会为容器自动处理。

### 资源共享和通信

在同一个pod中的应用程序使用相同的网络空间，可以通过`localhost`通信，在同一个pod中的应用必须协调端口的使用。每个pod都有一个ip地址，在一个扁平的网络中，可以和其他物理机或者pods通信。

除了在pod中定义应用容器，还可以定义一些共享的存储卷。这些卷可以保证在容器重启的时候将数据不丢并在应用间共享。

## 其他的替代选择

为什么不在一个容器里运行多个程序？

1. 透明。让pod中的容器对基础设施可见，以便基础设施能够为这些容器提供服务，比如进程管理和资源监控。可以给用户带来很大的方便。
2. 解耦。每个容器可以进行版本管理，独立编译和部署。Kubernetes在未来有可能支持单个容器的在线升级。
3. 易用。用户不需要运行自己的进程管理器，担心进程的退出等等。
4. 效率。因为由基础设施提供更多的职责，所以容器可以变得更加轻量级。

为什么不提供容器的亲和性调度？

这种方法可以提供容器的协同定位，能够根据容器的亲和性进行调度，但是无法实现使用pod带来的大部分好处，例如资源共享，IPC，保持状态一致性和简化管理等。

## Pods的持久性

Pods并不是持久性的实体。它们不会在调度失败，节点死亡，资源不足，节点维护等情况下存活下来。

通常而言，用户不需要去直接创建pods。它们都是通过控制器创建，比如[Deployments](deployments.md)。控制器提供集群级别的自愈、复制、升级功能。

## Pods的终止

因为pods是作为进程运行在集群上的节点上，所以当它们不再被需要时能够优雅的终止是很重要的。用户能够请求删除，直到进程何时终止，确保删除能够完成。当用户请求删除pods，pods在被强制删除前系统会记录一个优雅时间，这个时间内每个容器会收到`TERM`信号。一旦超过这个时间，进程会收到`KILL`信号，pod就会通过API服务器删除。如果在等待进程结束的同时`Kubelet`或者容器管理器重启了，这个终止操作会重新发送`TERM`信号直到超时。

流程如下：
1. 用户发送删除Pod的命令，默认优雅时间是30s。
2. 在超过优雅时间后，pod会被API服务器标记为`dead`状态。
3. 在客户端命令行上Pod的状态显示是`Terminating`。
4. 跟第3步同时，当Kubelet看到pod被标记为`Terminating`，开始关闭进程。
    1. 如果pod定义了`preStop hook`，它会被调用。如果`preStop hook`在超过优雅时间后仍然在运行，会将优雅时间延长2s。
    2. 在Pod内的进程会收到`TERM`信号。
5. 跟第3步同时，Pod会从服务端点列表里删除，不再是副本控制器的一部分。慢慢关闭的pods会依然提供服务直到负载均衡器把它们删除。
6. 当超过优雅时间后，依然在运行的进程会收到`SIGKILL`信号。
7. `Kubelet`完成pod的删除，API服务器将优雅时间设置为0，pod不再被客户端可见。

默认情况下，删除操作将在30s内优雅的完成。`kubectl delete`命令支持`--grace-period=<seconds>`参数，允许用户覆盖默认的30s时间。如果设置为0将强制删除pod。在kubectl>=1.5版本的命令中，你必须同时使用`--force`和`--grace-period=0`来强制删除pod。强制删除的操作请谨慎使用。

## 容器的特权模式

在Kubernetes 1.1版本后，在pod的每个容器支持特权模式，使用`privileged`标志在`SecurityContext`声明。这个模式可以允许容器使用linux的能力，比如操作网络栈和访问设备。在容器内的进程几乎和容器外的进程拥有相同的特权。在特权模式下，不需要修改和重新编译kubelet，就可以使用pod来开发节点的网络和存储插件。

## API对象

Pod是kubernetes REST API中的顶级资源类型。详情请参考[Pod API object](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)。

